#!/usr/bin/env python
# coding: utf-8

# # Module 01_02: Command Line Patching: 
# 
# ![Assets/SVC_results.png](Assets/SVC_results.png)
# ### Use nbconvert  patch_sklearn from command line

# # Learning Objectives:
# 
# - Describe how to import and apply patch_sklearn()
# - Describe how to import and apply unpatch_sklearn()
# - Describe method & apply the patch to an entire python program
# - Describe how to surgically unpatch specific optimized functions if needed
# - Describe a patching strategy that ensures that the Intel Extensions for scikit-learn runs as fast or faster than the stock algorithms it replaces
# - Apply patch methodology to speed up KNN on CovType dataset
# 
# # Steps
# 
# You will convert a Jupyter Notebook to a python file using "Jupyter nbconvert" and then apply the patch via the command line. Then you will run the patched python script to ensure that the patch has been applied.
# 
# * On your DevCloud instance:
# 1) click the blue + in the upper left of browser (the launcher) 
# 
# ![Assets/NewLauncher.jpg](Assets/NewLauncher.jpg)
# 
# 2) Scroll down in the launcher and Launch a Terminal
# 
# 
# ![Assets/LaunchTerminal.jpg](Assets/LaunchTerminal.jpg)
# 
# 
# - In the terminal:
# 1) Change directories to our current folder as follows:
# 1) - cd "ai_learning_paths/ML using oneAPI/01_Introduction to Intel Extensions for Scikit-learn Patching/" 
# 1) Convert Jupyter Notebook to a python script using Jupyter nbconvert script as follows:
# 1) - **jupyter nbconvert --to script SampleSVM_Notebook.ipynb**
# 1) Run a patched version of the python code as follows:
# 1)  - **python -m sklearnex SampleSVM_Notebook.py** 
# 1) Run the Unpatched version
# 1)  - **python  SampleSVM_Notebook.py**
# 1)  - the first run (**patched globally**) should take about **11 seconds**
# 1)  - the second run(**unpatched**) takes **1 to 2 minutes**
# 1) Edit the SampleSVM_Notebook.py and **surgically unpatch SVC explicitly** to force unpatching of this function
# 1)  - **python -m sklearnex SampleSVM_Notebook.py** 
# 1)  - Observe the time, did surgical unpatching override the global patching attempt?
# 1) Compare the times of execution of the all runs
# 1) compare the accuracy metrics of all runs
# 
# - Was there a significant difference in time or accuracy?
# 
# The above should run the python script and apply the sklearnex patch to the entire python file prior to executing the file
# 

# # Compare the times and accuracies of these two runs. 
# 
# Is the time versus accuracy trade off worth the effort to patch this function?
# 
# Reminder of how to find the list of functions available to patch
# 
# ## List the underlying patched functions to its containg library
# 

# In[ ]:


# return list of optimzed functions
from sklearnex import get_patch_names
get_patch_names()


# ## Use get_patch_map for more information
# 
# Below is how to get more information on which specific names to patch for surgical control. 
# 
# **Excercise:** Search for pairwise_distance and see if you can find the abreviation to use to surgically patch this algorithm.

# In[ ]:


from sklearnex import get_patch_names, get_patch_map
get_patch_map()


# # Summary:
# 
# You have:
# 
# 1) applied patching globally, by region in a cell, and surgically.
# 2) you have turned patching off
# 3) you are equpped to use any combination of patching strategy to control the maptching behavior of a given fucntion
# 4) Quiz?
# 5) - In lecture we learned that the sklearnex pairwise_distance only accepts metrics 'cosine' and 'correlation'. Assume you were dong pairwise_distance as follows:
# 5) - pairwise(distance(X, y)
# 6) - what is the default metric used?
# 7) - if you REQUIRED Euclidean distance, suggest a patching stratgey avoid having to change the call to pairwise distance but also get benefit of pathcing globally for all the rest of the notebook
#     

# In[ ]:


print("All Done")


# # Notices & Disclaimers 
# 
# Intel technologies may require enabled hardware, software or service activation.
# No product or component can be absolutely secure.
# 
# Your costs and results may vary.
# 
# Â© Intel Corporation. Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries. 
# *Other names and brands may be claimed as the property of others.

# In[ ]:




